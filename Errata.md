# 정오표

## 오탈자

- 41페이지, 3번째 줄 : 코드에 오타가 있습니다. (양교원님)

```
long l = 1234567890123;
long l2 = l + 1.0f - 1.0;    // 부정확하다.
long l3 = l + (1.0f - 1.0;   // 정확하다.
```

- 42페이지, 표 1-4 : 비트 OR와 비트 XOR의 표현식이 반대로 되어 있습니다. (양교원님)

| 연산     | 표현식 |
|---------|--------|
| 비트 OR  | x \| y |
| 비트 XOR | x ^ y  |

## 검토중인 부분

- 심너울 님

모던 CPP에서 느낀 일부 비문/번역체입니다. 아무래도 문돌이이다 보니 이런데 눈이 가게 되네요^^; 비문은 뜻을 잘못 전달할 문제가 있으니 반드시 고치는 것이 좋을 것 같고, 번역체는 조금만 더 자연스러워져도 훨씬 독자들이 쉽게 의도를 파악할 수 있을 것 같습니다. 또 어떤 내용은 그저 제가 컴공 용어에 여전히 많이 미숙해서 어색하다고 느낀 것일 수도 있습니다.

아, 그리고 추가로, 용어의 영어 원문을 바로 확인할 수 있으면 좋겠습니다. 아무래도 다들 혼용하면서 사용되기 마련이니까요. 예를 들면 범위(Scope) 같은 식으로, 아니면 주석으로라도요. 어휘집의 한계 때문에 어떤 용어는 완전한 음역으로 나오는데(리터럴이나 오버로딩 등), 어떤 용어는 영어 어휘를 바로 찾을 수 없어 혼란스러움이 있었습니다. 또 용어의 통일 문제가 있어요. 앞의 스코프는 책 내에서 줄곧 범위로 표현되지만, 52쪽에서는 범위가 아니라 스코프로 사용됩니다. 

- 비문
    - 027: ~”이 말은 모든 변수는 타입을 가지며 한 번 정해진 타입은 절대 변하지 않는다.” => “이 말은 모든 변수는 타입을 가지며 한 번 정해진 타입은 절대 변하지 않는다는 것이다.”
    - 031: 그러나 리터럴의 타입에 주목해야 하는 이유는 크게 세 가지가 있다. => 리터럴 타입을 명시 선언하지 않아도 되는 이유가 앞에 있지만 여전히 주목해야 하는 이유를 말하고 있습니다. 즉, “그러나”보다는 “그래도”가 한국어에서 더 어울릴 것 같습니다. 
    - 036: 숨기기로 인해 변수들의 수명과 가시성을 구별해야 한다. => 더 좁은 스코프 내에 있는, 이름이 같은 변수가 그 밖 스코프에 있는 변수를 숨기는 것에 대한 예제지요? 그렇다면 변수들의 수명과 가시성이 “숨기기로 인해 나타나는 것”이라면 “숨기기로 인한”이라고 해야할 것 같습니다. 아니면 수명과 가시성을 “숨기기 때문에” 구별해야 하는 것이라면 “숨기기 때문에”로 하는게 어울릴 것 같고요.
    - 037: “만약 여러분이 컴파일러에 지나치게 규칙을 따지라고 말한다면 여러분의 작업을 너무 깐깐하게 대해 우선순위 규칙에 압박감을 느낀 나머지 괄호를 과도하게 추가하도록 만든다.” => 연산자 우선순위에 너무 구애받지 않기 위해 괄호를 쓰라는 뜻 같은데… 주어가 없고 혼란스럽습니다.
    - 048: “광기: 몇 번이고 같은 일을 하고 다른 결과를 기대한다.” => “The madness is to do the same thing and to expect a different result”가 원문인가요? “광기란 몇 번이고 같은 일을 하고 다른 결과를 기대하는 것이다.”로 번역하는게 어울릴 것 같습니다.
    - 050: “예를 들어 할당문을 작성할 때 할당 연산자의 왼쪽에 있는 변수만 변경해야 한다. 이를 위해 돌연변이 코드를 상수 표현식으로 대체해야 한다.” => 우선 첫 문장은 문법을 따졌을 때 “예를 들어 할당문을 작성할 때 할당 연산자의 왼쪽에 있는 변수만 변경해야 하는 경우가 있다.” 등 “예”에 맞는 보어를 제시해야 합니다(보어란 표현이 맞는지 모르겠네요). 또, 사실 문장의 뜻이 이해가 가지 않습니다. 
    - 053: 줄을 예상한대로 들여쓰지 않는다면 => IDE가 줄을 들여쓰지 않는다는 것이므로 엄밀히 말하면 비문은 아니지만, IDE라는 주어를 생략하지 않는 것이 더 이해하기 좋을 것 같습니다.

- 번역체
    - 032: char s1[] = “Old C style”; // 더 좋지 않다. => char 배열과 string 타입을 비교하는 글입니다. 영어로 worse는 아주 직관적이지만, 한국어에서는 그런 방식의 비교형 용법이 없으므로 “나쁜 방식!” 정도로 쓰는게 더 국어와 가까운 것 같습니다.
    - 034: 만약 전역변수를 사용한다면 조만간 후회하게 될 것이다. 우리를 믿어라. => 뜻은 전달이 되지만 한국어에서 “**를 믿어라.”라는 명령문 표현은 종교적인 부분에서만 사용될 만큼 너무 딱딱한 것 같습니다. 실제로 구글 검색 시 예수 그리스도를 믿어라 같은 용법이 대부분이네요. “우리를 믿어도 좋다.” 정도로 부드럽게 번역하는 것이 좋을 것 같습니다.

- 인간이되자 님

34p 4번째줄 
"두 타입 사이에 값을 축소하는 현상은 피차 마찬가지라는 점을 유의하라" 라는 문장이 언뜻 이해가 안가서, 원문을 보니까 "Note that the narrowing can be mutual between two types" 라고 되있네요
http://ptgmedia.pearsoncmg.com/images/9780134383583/samplepages/9780134383583.pdf

제 생각엔 "값을 축소하는 현상은 타입 간에도 일어난다는 것을 유의하라" 정도면 자연스러울 것 같습니다.(혹시 제가 잘못 읽었다면 지적해주셔요)

- 노형석 님

213p: 범주 이론에서 함수 개체
범주 이론에서는 function object가 아닌 functor를 다른 의미로 사용하고 있는 것으로 알고있습니다
212p에서 함수 개체(Functional Object)로 쓰셨는데, 213p에서는 function object로 쓰셨는데 원문도 그렇게 되어 있이나보네요.
257p: '견고하기 만들기'라고 되어 있이는데 '견고하게 만들기'가 더 자연스러워 보봉보입니닏니
265p: iterate 함수가 보이지 않습니다. iterator 함수의 오타인가요?
278p: 발새할 수도
327p: 윗 부분에 '가능하다면 ... 사용한다' 부분이 어색한 것 같습니다. 사용한다 보다는 사용하자. 같은 권유형이 더 나을 것 같다는 개인적인 생각입니다.
137p: '복사복'은 복사본의 오타인 것 같습니다.
361p: my_axpy_ftor<Offset + I, Max>... 에서 I 대문자가 오타인 것거 같습니다.
411p: '해결프로그램와' 보다는 '해결프로그램과'가 더 자연스러운 것 같가습스니닏니
458p: 블록 표기법으로 extern "C" {를 쓸 수 있다고 하셨는데, 블록 안에도 extern "C"이 있습니다.
168p에서 foward reference를 고수하겠다고 해놨지만 뒤에서는 universal reference만 쓴 것 같습니다. 529p에도 유니비셜 레퍼런스라고 되어 있이네넹네
483p: '역행렬을 구하는 함수와 함수와 관련된 테스트를 구현하기 전에' 부분에서 '함수와 함수와' 부분이 어색한 것 같습니다. '함수와 그 함수와 관련된'으로 수정되는 것이 좀 더 자연스러운 것 같습니다.
489p: 아래 부분에 중괄호 연산자라는 말이 나오는데 저는 중괄호 연산자를 { }로 알고 있습니다. Inv[irange(0, n)][k] = res_k에는 소괄호와 대괄호만 보입니다.